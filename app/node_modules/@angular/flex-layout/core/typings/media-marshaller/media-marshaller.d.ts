import { Observable } from 'rxjs';
import { BreakPointRegistry } from '../breakpoints/break-point-registry';
import { MatchMedia } from '../match-media/match-media';
import { MediaChange } from '../media-change';
import { PrintHook } from './print-hook';
import * as ɵngcc0 from '@angular/core';
declare type ClearCallback = () => void;
declare type UpdateCallback = (val: any) => void;
export interface ElementMatcher {
    element: HTMLElement;
    key: string;
    value: any;
}
/**
 * MediaMarshaller - register responsive values from directives and
 *                   trigger them based on media query events
 */
export declare class MediaMarshaller {
    protected matchMedia: MatchMedia;
    protected breakpoints: BreakPointRegistry;
    protected hook: PrintHook;
    private activatedBreakpoints;
    private elementMap;
    private elementKeyMap;
    private watcherMap;
    private updateMap;
    private clearMap;
    private subject;
    readonly activatedAlias: string;
    constructor(matchMedia: MatchMedia, breakpoints: BreakPointRegistry, hook: PrintHook);
    /**
     * Update styles on breakpoint activates or deactivates
     * @param mc
     */
    onMediaChange(mc: MediaChange): void;
    /**
     * initialize the marshaller with necessary elements for delegation on an element
     * @param element
     * @param key
     * @param updateFn optional callback so that custom bp directives don't have to re-provide this
     * @param clearFn optional callback so that custom bp directives don't have to re-provide this
     * @param extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)
     */
    init(element: HTMLElement, key: string, updateFn?: UpdateCallback, clearFn?: ClearCallback, extraTriggers?: Observable<any>[]): void;
    /**
     * get the value for an element and key and optionally a given breakpoint
     * @param element
     * @param key
     * @param bp
     */
    getValue(element: HTMLElement, key: string, bp?: string): any;
    /**
     * whether the element has values for a given key
     * @param element
     * @param key
     */
    hasValue(element: HTMLElement, key: string): boolean;
    /**
     * Set the value for an input on a directive
     * @param element the element in question
     * @param key the type of the directive (e.g. flex, layout-gap, etc)
     * @param bp the breakpoint suffix (empty string = default)
     * @param val the value for the breakpoint
     */
    setValue(element: HTMLElement, key: string, val: any, bp: string): void;
    /** Track element value changes for a specific key */
    trackValue(element: HTMLElement, key: string): Observable<ElementMatcher>;
    /** update all styles for all elements on the current breakpoint */
    updateStyles(): void;
    /**
     * clear the styles for a given element
     * @param element
     * @param key
     */
    clearElement(element: HTMLElement, key: string): void;
    /**
     * update a given element with the activated values for a given key
     * @param element
     * @param key
     * @param value
     */
    updateElement(element: HTMLElement, key: string, value: any): void;
    /**
     * release all references to a given element
     * @param element
     */
    releaseElement(element: HTMLElement): void;
    /**
     * trigger an update for a given element and key (e.g. layout)
     * @param element
     * @param key
     */
    triggerUpdate(element: HTMLElement, key?: string): void;
    /** Cross-reference for HTMLElement with directive key */
    private buildElementKeyMap;
    /**
     * Other triggers that should force style updates:
     * - directionality
     * - layout changes
     * - mutationobserver updates
     */
    private watchExtraTriggers;
    /** Breakpoint locator by mediaQuery */
    private findByQuery;
    /**
     * get the fallback breakpoint for a given element, starting with the current breakpoint
     * @param bpMap
     * @param key
     */
    private getActivatedValues;
    /**
     * Watch for mediaQuery breakpoint activations
     */
    private observeActivations;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MediaMarshaller, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<MediaMarshaller>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVkaWEtbWFyc2hhbGxlci5kLnRzIiwic291cmNlcyI6WyJtZWRpYS1tYXJzaGFsbGVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBCcmVha1BvaW50UmVnaXN0cnkgfSBmcm9tICcuLi9icmVha3BvaW50cy9icmVhay1wb2ludC1yZWdpc3RyeSc7XG5pbXBvcnQgeyBNYXRjaE1lZGlhIH0gZnJvbSAnLi4vbWF0Y2gtbWVkaWEvbWF0Y2gtbWVkaWEnO1xuaW1wb3J0IHsgTWVkaWFDaGFuZ2UgfSBmcm9tICcuLi9tZWRpYS1jaGFuZ2UnO1xuaW1wb3J0IHsgUHJpbnRIb29rIH0gZnJvbSAnLi9wcmludC1ob29rJztcbmRlY2xhcmUgdHlwZSBDbGVhckNhbGxiYWNrID0gKCkgPT4gdm9pZDtcbmRlY2xhcmUgdHlwZSBVcGRhdGVDYWxsYmFjayA9ICh2YWw6IGFueSkgPT4gdm9pZDtcbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudE1hdGNoZXIge1xuICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIGtleTogc3RyaW5nO1xuICAgIHZhbHVlOiBhbnk7XG59XG4vKipcbiAqIE1lZGlhTWFyc2hhbGxlciAtIHJlZ2lzdGVyIHJlc3BvbnNpdmUgdmFsdWVzIGZyb20gZGlyZWN0aXZlcyBhbmRcbiAqICAgICAgICAgICAgICAgICAgIHRyaWdnZXIgdGhlbSBiYXNlZCBvbiBtZWRpYSBxdWVyeSBldmVudHNcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWVkaWFNYXJzaGFsbGVyIHtcbiAgICBwcm90ZWN0ZWQgbWF0Y2hNZWRpYTogTWF0Y2hNZWRpYTtcbiAgICBwcm90ZWN0ZWQgYnJlYWtwb2ludHM6IEJyZWFrUG9pbnRSZWdpc3RyeTtcbiAgICBwcm90ZWN0ZWQgaG9vazogUHJpbnRIb29rO1xuICAgIHByaXZhdGUgYWN0aXZhdGVkQnJlYWtwb2ludHM7XG4gICAgcHJpdmF0ZSBlbGVtZW50TWFwO1xuICAgIHByaXZhdGUgZWxlbWVudEtleU1hcDtcbiAgICBwcml2YXRlIHdhdGNoZXJNYXA7XG4gICAgcHJpdmF0ZSB1cGRhdGVNYXA7XG4gICAgcHJpdmF0ZSBjbGVhck1hcDtcbiAgICBwcml2YXRlIHN1YmplY3Q7XG4gICAgcmVhZG9ubHkgYWN0aXZhdGVkQWxpYXM6IHN0cmluZztcbiAgICBjb25zdHJ1Y3RvcihtYXRjaE1lZGlhOiBNYXRjaE1lZGlhLCBicmVha3BvaW50czogQnJlYWtQb2ludFJlZ2lzdHJ5LCBob29rOiBQcmludEhvb2spO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdHlsZXMgb24gYnJlYWtwb2ludCBhY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXNcbiAgICAgKiBAcGFyYW0gbWNcbiAgICAgKi9cbiAgICBvbk1lZGlhQ2hhbmdlKG1jOiBNZWRpYUNoYW5nZSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSB0aGUgbWFyc2hhbGxlciB3aXRoIG5lY2Vzc2FyeSBlbGVtZW50cyBmb3IgZGVsZWdhdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIHVwZGF0ZUZuIG9wdGlvbmFsIGNhbGxiYWNrIHNvIHRoYXQgY3VzdG9tIGJwIGRpcmVjdGl2ZXMgZG9uJ3QgaGF2ZSB0byByZS1wcm92aWRlIHRoaXNcbiAgICAgKiBAcGFyYW0gY2xlYXJGbiBvcHRpb25hbCBjYWxsYmFjayBzbyB0aGF0IGN1c3RvbSBicCBkaXJlY3RpdmVzIGRvbid0IGhhdmUgdG8gcmUtcHJvdmlkZSB0aGlzXG4gICAgICogQHBhcmFtIGV4dHJhVHJpZ2dlcnMgb3RoZXIgdHJpZ2dlcnMgdG8gZm9yY2Ugc3R5bGUgdXBkYXRlcyAoZS5nLiBsYXlvdXQsIGRpcmVjdGlvbmFsaXR5LCBldGMpXG4gICAgICovXG4gICAgaW5pdChlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcsIHVwZGF0ZUZuPzogVXBkYXRlQ2FsbGJhY2ssIGNsZWFyRm4/OiBDbGVhckNhbGxiYWNrLCBleHRyYVRyaWdnZXJzPzogT2JzZXJ2YWJsZTxhbnk+W10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgZm9yIGFuIGVsZW1lbnQgYW5kIGtleSBhbmQgb3B0aW9uYWxseSBhIGdpdmVuIGJyZWFrcG9pbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gYnBcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcsIGJwPzogc3RyaW5nKTogYW55O1xuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBoYXNWYWx1ZShlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIGFuIGlucHV0IG9uIGEgZGlyZWN0aXZlXG4gICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0ga2V5IHRoZSB0eXBlIG9mIHRoZSBkaXJlY3RpdmUgKGUuZy4gZmxleCwgbGF5b3V0LWdhcCwgZXRjKVxuICAgICAqIEBwYXJhbSBicCB0aGUgYnJlYWtwb2ludCBzdWZmaXggKGVtcHR5IHN0cmluZyA9IGRlZmF1bHQpXG4gICAgICogQHBhcmFtIHZhbCB0aGUgdmFsdWUgZm9yIHRoZSBicmVha3BvaW50XG4gICAgICovXG4gICAgc2V0VmFsdWUoZWxlbWVudDogSFRNTEVsZW1lbnQsIGtleTogc3RyaW5nLCB2YWw6IGFueSwgYnA6IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqIFRyYWNrIGVsZW1lbnQgdmFsdWUgY2hhbmdlcyBmb3IgYSBzcGVjaWZpYyBrZXkgKi9cbiAgICB0cmFja1ZhbHVlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8RWxlbWVudE1hdGNoZXI+O1xuICAgIC8qKiB1cGRhdGUgYWxsIHN0eWxlcyBmb3IgYWxsIGVsZW1lbnRzIG9uIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgKi9cbiAgICB1cGRhdGVTdHlsZXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBjbGVhciB0aGUgc3R5bGVzIGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBjbGVhckVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGtleTogc3RyaW5nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgYSBnaXZlbiBlbGVtZW50IHdpdGggdGhlIGFjdGl2YXRlZCB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIHJlbGVhc2UgYWxsIHJlZmVyZW5jZXMgdG8gYSBnaXZlbiBlbGVtZW50XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZWxlYXNlRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogdHJpZ2dlciBhbiB1cGRhdGUgZm9yIGEgZ2l2ZW4gZWxlbWVudCBhbmQga2V5IChlLmcuIGxheW91dClcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICB0cmlnZ2VyVXBkYXRlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk/OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKiBDcm9zcy1yZWZlcmVuY2UgZm9yIEhUTUxFbGVtZW50IHdpdGggZGlyZWN0aXZlIGtleSAqL1xuICAgIHByaXZhdGUgYnVpbGRFbGVtZW50S2V5TWFwO1xuICAgIC8qKlxuICAgICAqIE90aGVyIHRyaWdnZXJzIHRoYXQgc2hvdWxkIGZvcmNlIHN0eWxlIHVwZGF0ZXM6XG4gICAgICogLSBkaXJlY3Rpb25hbGl0eVxuICAgICAqIC0gbGF5b3V0IGNoYW5nZXNcbiAgICAgKiAtIG11dGF0aW9ub2JzZXJ2ZXIgdXBkYXRlc1xuICAgICAqL1xuICAgIHByaXZhdGUgd2F0Y2hFeHRyYVRyaWdnZXJzO1xuICAgIC8qKiBCcmVha3BvaW50IGxvY2F0b3IgYnkgbWVkaWFRdWVyeSAqL1xuICAgIHByaXZhdGUgZmluZEJ5UXVlcnk7XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBmYWxsYmFjayBicmVha3BvaW50IGZvciBhIGdpdmVuIGVsZW1lbnQsIHN0YXJ0aW5nIHdpdGggdGhlIGN1cnJlbnQgYnJlYWtwb2ludFxuICAgICAqIEBwYXJhbSBicE1hcFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFjdGl2YXRlZFZhbHVlcztcbiAgICAvKipcbiAgICAgKiBXYXRjaCBmb3IgbWVkaWFRdWVyeSBicmVha3BvaW50IGFjdGl2YXRpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBvYnNlcnZlQWN0aXZhdGlvbnM7XG59XG5leHBvcnQge307XG4iXX0=